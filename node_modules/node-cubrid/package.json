{
  "name": "node-cubrid",
  "version": "2.2.0",
  "description": "This is a Node.js driver for CUBRID RDBMS. It is developed in 100% JavaScript and does not require specific platform compilation.",
  "author": {
    "name": "CUBRID",
    "email": "contact@cubrid.org",
    "url": "http://www.cubrid.org/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/cubrid/node-cubrid.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/cubrid/node-cubrid/raw/master/LICENSE"
    }
  ],
  "main": "index.js",
  "keywords": [
    "native",
    "CUBRID",
    "SQL",
    "Database",
    "RDBMS",
    "driver",
    "API",
    "module"
  ],
  "engines": {
    "node": "*"
  },
  "scripts": {
    "clean": "rm -rf src-cov",
    "instrument": "npm run clean && jscoverage src src-cov",
    "cover": "npm run instrument && CODE_COV=1 NODE_ENV=test ./node_modules/.bin/nodeunit --reporter=lcov test | node test/testSetup/fix_lcov.js | ./node_modules/.bin/coveralls",
    "test": "./node_modules/.bin/nodeunit test"
  },
  "devDependencies": {
    "async": "~0.8.0",
    "coveralls": "~2.10.0",
    "generic-pool": "~2.0.4",
    "nodeunit": "~0.9.0"
  },
  "readme": "# node-cubrid\n\n[![Build Status](https://travis-ci.org/CUBRID/node-cubrid.png)](https://travis-ci.org/CUBRID/node-cubrid)\n[![Coverage Status](https://coveralls.io/repos/CUBRID/node-cubrid/badge.png)](https://coveralls.io/r/CUBRID/node-cubrid)\n\n## Introduction\n\nThis is a Node.js driver for [CUBRID](http://www.cubrid.org) open-source relational database. **node-cubrid** is implemented in 100% JavaScript with no external dependency. Besides the database specific APIs, the module supplies several *helper* APIs which are useful to sanitize and validate user input values, format and parameterize SQL statements, etc.\n\n## Key features\n\n- Full compatibility with CUBRID 8.4.1+ releases.\n- Rich database support: Connect, Query, Fetch, Execute, Execute in batch, Commit, Rollback, etc.\n- Support for queries queueing.\n- Support for database schema.\n- Support for database parameters and transactions.\n- Support for [LOB](http://www.cubrid.org/manual/92/en/sql/datatype.html#blob-clob-data-types) objects.\n- Support for [ENUM](http://www.cubrid.org/manual/92/en/sql/datatype.html#enum-data-type) data types since CUBRID 9+.\n- Fully implements the event emitter.\n- Extensive tests suite (260K+ assertions).\n- User demos: E2E scenarios, web sites.\n- ...and many more!\n\n## CHANGELOG\n\nYou can find the change logs in [CHANGELOG.md](https://github.com/CUBRID/node-cubrid/blob/master/CHANGELOG.md) file.\n\n## Installation\n\nInstalling and using **node-cubrid** is easy. To install, one has to initiate `npm install` command with `node-cubrid` module name as an argument in the directory where a Node.js application is located.\n\n\tnpm install node-cubrid\n\nThis will install the latest version available at [https://npmjs.org/](https://npmjs.org/). Once installed, the module can be accessed by requiring the `node-cubrid` module:\n\n\tvar CUBRID = require('node-cubrid');\n\nThe node-cubrid module exports the following properties and functions:\n\n* `ActionQueue`: an object which provides the [`waterfall()`](https://github.com/caolan/async#waterfall) functionality of [async](https://github.com/caolan/async) module. \n* `Helpers`: an object which provides a set of helper functions.\n* `Result2Array`: an object which provides functions to convert DB result sets into JS arrays.\n* `createCUBRIDConnection()` or `createConnection()`: a function which returns a connection object to work with a user defined CUBRID host and database.\n* `createDefaultCUBRIDDemodbConnection()`: a function which returns a connection object to work with a local [demodb](http://blog.cubrid.org/wiki_tutorials/entry/getting-started-with-demodb-cubrid-demo-database) database.\n\n## Request flow in node-cubrid\n\nThe request flow in node-cubrid module looks as illustrated below.\n\n![Figure 1: Request flow in node-cubrid](http://blog.cubrid.org/files/attach/images/194379/839/471/cubrid_nodejs_events_chain.png)\n\nBecause **node-cubrid** is developed to take the full advantage of JavaScript and Node.js programming, when executing a SQL statement in **node-cubrid**, developers need to listen for an `EVENT_QUERY_DATA_AVAILABLE` and `EVENT_ERROR` events, or provide a callback function which will be called once there is a response from the server.\n\nWhen the request is sent to the server, CUBRID executes it, and returns the response, which can be either a query result set, or the error code. It is by design that CUBRID does not return any identification about the request sender. In other words, in order to associate the response with a request, the driver has to have only one active request which can be the only owner of this response.\n\nFor this reason, if a developer wants to execute several queries, they must execute them one after another, i.e. sequentially, NOT in parallel. This is how the communication between the driver and the server is implemented in CUBRID and most other database systems including MySQL.\n\nIf there is a vital need to run queries in parallel, developers can use connection pooling modules. An example with this technique is provided below.\n\n## API Documentation\n\n### Creating a CUBRID client\n\n\t// `createCUBRIDConnection()` function accepts either an object or a list of\n\t// connection parameters. The following list of parameters are supported at\n\t// this moment:\n\t// 1. `host`: an IP or a domain name of the CUBRID host (without http:// part).\n\t// \t   Defaults to `localhost`.\n\t// 2. `port`: a port CUBRID is listening at. Defaults to `33000`.\n\t// 3. `user`: the database username. Defaults to `public`.\n\t// 4. `password`: the database user password. Defaults to an empty string.\n\t// 5. `database`: the name of a database to connect to. Default to `demodb`.\n\t// 6. `cacheTimeout`: the timeout value in milliseconds for the query results\n\t//\t  cache. All query results will be cached if `cacheTimeout > 0`. The\n\t//\t  cached results will be returned if the same SQL query is executed within\n\t// \t  the timeout period. Defaults to `0`.\n\t// 7. `connectionTimeout`: the timeout value in milliseconds for the connection.\n\t//\t  If `connectionTimeout = 0`, it will wait until the network socket times out\n\t//\t  itself. Defaults to `0`.\n\n\t// All arguments are optional in which case default values will be set.\n\tvar client = CUBRID.createCUBRIDConnection(host, port, user, password, database, cacheTimeout, connectionTimeout);\n\n\t// Alias function since version 2.1.0.\n\tvar client = CUBRID.createConnection(host, port, user, password, database, cacheTimeout, connectionTimeout);\n\t\n\t// Alternatively, an object of parameters can be passed. Since version 2.1.0.\n\tvar client = CUBRID.createConnection(paramsObject);\n\nThe following example shows how to create a client by providing an object of connection parameters.\n\n\tvar client = CUBRID.createConnection({\n\t\thost: host,\n\t\tport: port,\n\t\tuser: user,\n\t\tpassword: password:\n\t\tdatabase: database,\n\t\tcacheTimeout: cacheTimeout,\n\t\tconnectionTimeout: connectionTimeout\n\t});\n\n### Establishing a connection\n\n\t// callback(err) function receives one arguments: the error message if any.\n\tclient.connect(callback);\n\n#### Callback style\n\nThe code below illustrates a *callback* style when a function is passed as an argument to a `connect()` API which is called after the module receives a response from CUBRID.\n\n\tvar CUBRID = require('node-cubrid'),\n\t\t\tdbConf = {\n\t\t\t\thost: 'localhost',\n\t\t\t\tport: 33000,\n\t\t\t\tuser: 'public'\n\t\t\t\tpassword: '',\n\t\t\t\tdatabase: 'demodb'\n\t\t\t},\n\t\t\tclient = CUBRID.createCUBRIDConnection(dbConf.host, dbConf.port, dbConf.user, dbConf.password, dbConf.database);\n\t\n\tclient.connect(function (err) {\n\t\tif (err) {\n\t\t\tthrow err;\n\t\t} else {\n\t\t\tconsole.log('connection is established');\n\t\t\t\n\t\t\tclient.close(function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow err;\n\t\t\t\t} else {\t\t\t\n\t\t\t\t\tconsole.log('connection is closed');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n#### Event-based style\n\nAlternatively, developers can write applications based on an event-based coding style. For example, the above code can be rewritten as:\n\n\tclient.connect();\n\t\n\tclient.on(client.EVENT_ERROR, function (err) {\n\t\tthrow err;\n\t});\n\n\tclient.on(client.EVENT_CONNECTED, function () {\n\t\t\tconsole.log('connection is established');\n\t\t\t\n\t\t\tclient.close();\n\t});\n\n\tclient.on(client.EVENT_CONNECTION_CLOSED, function () {\n\t\t\tconsole.log('connection is closed');\n\t});\n\nIf you prefer the event-based coding style, refer to the [Driver Event model](http://blog.cubrid.org/wiki_apis/entry/cubrid-node-js-api-overview) wiki page to learn more about other events **node-cubrid** emits for certain API calls.\n\n#### Implicit connection\n\n**node-cubrid** also provides implicit connection feature. When you execute a query on a client without explicitly establishing a connection with `client.connect()`, the driver will automatically establish a connection, then execute your query.\n\n#### Connection errors\n\nThere can be several reasons for a connection to fail:\n\n1. **Connection timeout**:\n\t1. when the host does not respond within the specified time larger than `0`, you will receive the following error message emitted by **node-cubrid**:\n\n\t\t\t{ [Error: connect ETIMEDOUT] }\n\n\t2. when no timeout value is set or its value is `0`, the following timeout error is emitted by the underlying network socket.\n\n\t\t\t{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }\n\n2. **Incorrect hostname**:\n\n\t\t{ [Error: getaddrinfo ENOTFOUND] code: 'ENOTFOUND', errno: 'ENOTFOUND', syscall: 'getaddrinfo' }\n\n3. **Incorrect port**:\n\t* When you try to connect to a port listened by an active service other than CUBRID or if a firewall refuses the connection, you will see the following error message:\n\t\n\t\t\t{ [Error: connect ECONNREFUSED] code: 'ECONNREFUSED', errno: 'ECONNREFUSED', syscall: 'connect' }\n\t\n\t* If the port is not listened by any service, then you will see the **Connection timeout** error as in the first case.\n\t* The last type of error message you would receive if an incorrect port is provided is:\n\n\t\t\t{ [Error: read ECONNRESET] code: 'ECONNRESET', errno: 'ECONNRESET', syscall: 'read' }\n\n### Connection configuration\n\n#### Setting connection timeout\n\n\t// Both functions are available since version 2.0.0.\n\tvar timeoutInMsec = client.getConnectionTimeout();\n\t// Set connection timeout in milliseconds.\n\tclient.setConnectionTimeout(2000);\n\t\n\t// Alternatively, set the connection timeout value at client creation time.\n\t// Available since version 2.1.0.\n\tvar client = CUBRID.createConnection(host, port, user, password, database, cacheTimeout, connectionTimeout);\n\nOne of the requests we have got for the 2.0 driver release was to implement a connection timeout feature. Simply said - wait for the connection to the database to complete within the specified number of seconds and eventually throw an error if the timeout occurs.\n\nObviously, the key thing here was to set the connection timeout at the Node.js socket connection layer level (and not on the consumer level):\n\n\tself._socket = Net.createConnection(self.initialBrokerPort, self.brokerServer);\n\tself._socket.setNoDelay(true);\n\tself._socket.setTimeout(this._CONNECTION_TIMEOUT);\n\nIn **node-cubrid** by default the connection timeout value is set to `0`, i.e. **node-cubrid** will wait long enough until the underlying network socket times out itself. In this case, according to our observations, the `timeout` event is emitted in about 75 seconds (**purely observational point**).\n\nSo, if you want or expect the connection to timeout within the specified time, then manually set the timeout value as shown below.\n\n\tvar client = new CUBRIDConnection(dbConf.host, dbConf.port, dbConf.user, dbConf.password, dbConf.database);\n \n \t// 2 seconds timeout.\n\tclient.setConnectionTimeout(2000);\n\t\n\tclient.connect(function (err) {\n\t\tif (err) {\n  \t\t\tconsole.log(err);\n\t\t}\n\t\t\n\t\tclient.close();\n\t});\n\nAs you see, the timeout is specified in milliseconds `2,000`, which is 2 seconds. After the 2 seconds, the script will timeout:\n\n\t{ [Error: connect ETIMEDOUT] }\n\n#### Setting CUBRID Server Parameters\n\n\t// Both functions are available since version 2.0.0.\n\tclient.getDatabaseParameter(paramType);\n\tclient.setDatabaseParameter(paramType, paramValue);\n\nAfter connecting to a database, a user can override some *global* session parameters that will control the behavior queries being executed. For example, isolation level of transactions, the auto-commit behavior, etc.\n\nThe complete list of these CUBRID database parameters is defined in the [`Constants.js` ](https://github.com/CUBRID/node-cubrid/blob/master/src/constants/CASConstants.js#L367) file:\n\n\t/**\n\t * Define CUBRID Database parameters constants\n\t */\n\texports.CCIDbParam = {\n\t\tCCI_PARAM_ISOLATION_LEVEL   : 1,\n\t\tCCI_PARAM_LOCK_TIMEOUT      : 2,\n\t\tCCI_PARAM_MAX_STRING_LENGTH : 3,\n\t\tCCI_PARAM_AUTO_COMMIT       : 4\n\t};\n\nFor each parameter, the CUBRID communication protocol implements a dedicated support for GET and SET operations. Therefore, in order to manipulate them, also a dedicate functionality was needed in the Node.js driver and this is what we did in the 2.0 release.\n\nPlease note one exception - the `CCI_PARAM_MAX_STRING_LENGTH` parameter **cannot** be set programmatically from code as it is a CUBRID Broker parameter and the client can only query its current value.\n\nLet’s see some examples. First, let set the value of the `ISOLATION_LEVEL` parameter:\n\n\tvar CAS = require('./node_modules/node-cubrid/src/constants/CASConstants');\n\t\n\tclient.connect(function (err) {\n\t\t// handle error, then...\n\t\tclient.setDatabaseParameter(CAS.CCIDbParam.CCI_PARAM_ISOLATION_LEVEL, CAS.CUBRIDIsolationLevel.TRAN_REP_CLASS_COMMIT_INSTANCE, function (err) {\n\t\t\t// handle error\n        \tCUBRIDClient.close(function (err) {\n\t\t\t\t// …\n\t\t\t});\n\t\t});\n\t});\nAnd let’s see how we can retrieve the value of the `LOCK_TIMEOUT` parameter for the current session:\n\n\tclient.connect(function (err) {\n\t\tclient.getDatabaseParameter(CAS.CCIDbParam.CCI_PARAM_LOCK_TIMEOUT, function (err, value) {\n\t\t\t// handle error, then...\n\t    \tconsole.log('LOCK_TIMEOUT is: %s', value);\n\t    \t\n    \t\tCUBRIDClient.close(function (err) {\n    \t\t\t// ...\n    \t\t});\n\t  \t});\n\t});\n\nThe output result is:\n\n\tLOCK_TIMEOUT is: -1\n\n**Note**: The same value can be obtained also from CUBRID Manager Client:\n\n![Figure 2: CUBRID Manager](http://blog.cubrid.org:8080/files/attach/images/194379/729/617/manager.png)\n\nIf you need to change the default values for these parameters, it is highly recommended to do it immediately after `connect ()`. One consequence is that you **must** use an explicit `connect ()` statement in your application, and not the **implicit connect** driver feature (the **implicit connect** feature means that the driver can auto-connect when a query is first executed without the need to issues an explicit `connect()` command).\n\n### Executing SQL queries\n\n#### READ queries\n\n\t// Callback style.\n\tclient.query(sql, callback);\n\tclient.query(sql, params, callback);\n\n\t// `sql` is a string representation of a READ query. Required.\n\t\n\t// `params` is an array of parameter values or the value itself\n\t//          which a user wants to bind instead of `?` placeholders\n\t//          in the `sql` query. If no placeholder is found, the `sql`\n\t//          will not be modified. This argument is optional. When\n\t//          omitted, `sql` will be sent to the server unmodified. This\n\t//          `params` argument is available since version 2.1.0.\n\t\n\t// `callback` is a function which will be invoked when the query\n\t//          finishes executing. Optional. The `callback` function\n\t//          can be omitted in which case only the\n\t//          `EVENT_QUERY_DATA_AVAILABLE` event will be\n\t//          emitted when the query finishes execution.\n\t\n\t// The `callback(err, result, queryHandle)` function accepts three arguments.\n\t// 1. `err`: an error object if any.\n\t// 2. `result`: a string value of the query result. No type casting as of version 2.1.0. Users need to parse the value into JSON manually.\n\t// 3. `queryHandle`: an integer ID for the query handle. Used to fetch more data.\n\t\t\n\t// Event style.\n\tclient.query(sql);\n\tclient.query(sql, params);\n\t\n\t// `callback(result, queryHandle, sql)` function accepts three arguments:\n\t// 1. `result`: a string value of the query result. No type casting as of version 2.1.0.\n\t// 2. `queryHandle`: an integer ID for the query handle. Used to fetch more data.\n\t// 3. `sql`: the SQL query which was executed that matches the `result`.\n\t// \t  `sql` argument is available since version 2.0.0.\n\tclient.on(client.EVENT_QUERY_DATA_AVAILABLE, callback);\n\t\n\t// Queries queueing.\n\tclient.query(sql);\n\tclient.query(sql, params);\n\t\n\t// When multiple queries are executed one after another without\n\t// waiting for a callback or listening for an emmitted event, the queries\n\t// will be queued and executed sequentially. Thus, callbacks and\n\t// appropriate events will be executed/emitted in order.\n\n##### Callback example\n\nHere is an example which executes a simple `SELECT\t` query.\n\n\tvar CUBRID = require('node-cubrid'),\n\t\t// `Result2Array` is a sub-module which provides a set of helper\n\t\t// functions to convert the query result to array, object, etc.\n\t\tResult2Array = CUBRID.Result2Array;\n\t\n\t// Connection is established implicitly.\n\tclient.query('SELECT * FROM nation', function (err, result, queryHandle) {\n      if (err) {\n        throw err;\n      } else {\n        var arr = Result2Array.RowsArray(result);\n        \n        for (var j = 0, len = arr.length; j < len; ++j) {\n          console.log(arr[j]);\n        }\n        \n        // Fetch more data using queryHandle if necessary.\n      }\n    });\n\nThe following example shows how to set placeholders and bind values in `SELECT` queries.\n\n\tclient.query('SELECT * FROM nation WHERE continent = ?', ['Asia'], function (err, result, queryHandle) {\n      if (err) {\n        throw err;\n      } else {\n        var arr = Result2Array.RowsArray(result);\n        \n        for (var j = 0, len = arr.length; j < len; ++j) {\n          console.log(arr[j]);\n        }\n        \n        // Fetch more data using queryHandle if necessary.\n      }\n    });\n\nAlternatively, the `params` value can be literal value.\n\n\tclient.query('SELECT * FROM nation WHERE continent = ?', 'Asia', callback);\n\nIf the `params` value is `undefined` or `null`, it will be converted to SQL `NULL`.\n\n\tclient.query('SELECT * FROM nation WHERE continent IS ?', null, callback);\n\nThe `Date` type values will be converted into CUBRID compatible `DATETIME` strings.\n\n\tclient.query('SELECT * FROM game WHERE game_date = ?', [new Date('8/28/2004')], callback);\n\t// The query will be\n\t// `SELECT * FROM game WHERE game_date = '8/28/2004 0:0:0.0'`\n\nAnd finally, everything else will be safely escaped and wrapped in single quotes.\n\n##### Event style example\n\n\t// Multiple queries will be queued and executed sequentially.\n\tclient.query('SELECT * FROM nation');\n\tclient.query('SELECT * FROM nation WHERE continent = ?', ['Asia']);\n\t\n\tclient.on(client.EVENT_QUERY_DATA_AVAILABLE, function (result, queryHandle, sql) {\n      var arr = Result2Array.RowsArray(result);\n        \n      for (var j = 0, len = arr.length; j < len; ++j) {\n        console.log(arr[j]);\n      }\n      \n\t  // Do something with `sql` like:\n\t  switch (sql) {\n\t    case SQL_A: \n\t      break;\n\t    case SQL_B:\n\t      break;\n\t    default:\n\t  }\n        \n      // Fetch more data using queryHandle if necessary.\n    }\n\n#### Fetch more data\n\n\t// Callback style.\n\t// `queryHandle`: an integer ID for the query handle obtained from query() function.\n\t// `callback(err, result, queryHandle)` function accepts three arguments.\n\t// 1. `err`: an error object if any.\n\t// 2. `result`: a string value of the query result. No type casting as of version 2.1.0.\n\t// 3. `queryHandle`: an integer ID for the query handle. Used to fetch more data.\n\tclient.fetch(queryHandle, callback);\n\t\n\t// Event style.\n\tclient.fetch(sql);\n\t// `callback(result, queryHandle)` function accepts two arguments.\n\tclient.on(client.EVENT_FETCH_DATA_AVAILABLE, callback);\n\t// `callback(queryHandle)` function accepts one argument.\n\tclient.on(client.EVENT_FETCH_NO_MORE_DATA_AVAILABLE, callback);\n\n##### Callback example\n\n\tclient.query('SELECT * FROM nation', function (err, result, queryHandle) {\n      if (err) {\n        throw err;\n      } else {\n        var arr = Result2Array.RowsArray(result);\n        \n        for (var j = 0, len = arr.length; j < len; ++j) {\n          console.log(arr[j]);\n        }\n        \n        // Fetch more data using queryHandle if necessary.\n        client.fetch(queryHandle, function (err, result, queryHandle) {\n        \t// Do the above logic here again.\n        });\n      }\n    });\n\n##### Event style example\n\n\tclient.query('SELECT * FROM nation');\n\n\tclient.on(client.EVENT_QUERY_DATA_AVAILABLE, function (result, queryHandle) {\n      var arr = Result2Array.RowsArray(result);\n        \n      for (var j = 0, len = arr.length; j < len; ++j) {\n        console.log(arr[j]);\n      }\n        \n      // Fetch more data using queryHandle if necessary.\n      client.fetch(queryHandle);\n    }\n\n\tclient.on(client.EVENT_FETCH_DATA_AVAILABLE, function (result, queryHandle) {\n      var arr = Result2Array.RowsArray(result);\n        \n      for (var j = 0, len = arr.length; j < len; ++j) {\n        console.log(arr[j]);\n      }\n        \n      // Continue fetching.\n      client.fetch(queryHandle);\n    }\n\n\tclient.on(client.EVENT_FETCH_NO_MORE_DATA_AVAILABLE, function (queryHandle) {\n      // Close query;\n    }\n\n#### Close Query\n\n\t// `queryHandle`: an integer ID for the query handle obtained from `query()`\n\t// or the last `fetch()` function.\n\t// `callback(err, queryHandle)` function accepts two arguments:\n\t// 1. `err`: an error object if any.\n\t// 2. `queryHandle`: the query handle which has been closed.\n\tclient.closeQuery(queryHandle, callback);\n\t\n\t// Event style.\n\tclient.closeQuery(queryHandle);\n\t// `callback(queryHandle)` function accepts one argument:\n\t// `queryHandle`: the query handle ID which was just closed.\n\tclient.on(client.EVENT_QUERY_CLOSED, callback);\n\nAll READ queries must be closed explicitly.\n\n##### Callback example\n\n\tclient.query(sql, function (err, result, queryHandle) {\n\t\tvar arr = Result2Array.RowsArray(result);\n\t\t\n\t\tif (arr.length) {\n\t\t\t// Try to fetch more.\n\t\t} else {\n\t\t\tclient.closeQuery(queryHandle, function (err, queryHandle) {\n\t\t\t\t// Do something else.\n\t\t\t});\n\t\t}\n\t});\n\n##### Event style example\n\n\tclient.on(client.EVENT_FETCH_NO_MORE_DATA_AVAILABLE, function (queryHandle) {\n\t\tclient.closeQuery(queryHandle);\n    }\n    \n    client.on(client.EVENT_QUERY_CLOSED, function (queryHandle) {\n\t\t// Do something here.\n    }\n\n#### WRITE queries\n\n\t// `sql` is a string which represents a WRITE query or an array of strings\n\t// for batch processing.\n\t// `callback(err)` function accepts one argument: an error object if any.\n\tclient.execute(sql, callback);\n\n##### Example\n\n\tclient.execute('CREATE TABLE tbl_test(id INT)', function (err) {\n      if (err) {\n        throw err;\n      } else {\n        // Do something else.\n      }\n    });\n\nAfter executing WRITE queries there is no need to close the query.\n\n#### Queueing\n\nSince **node-cubrid** version 2.1.0 almost all requests, which initiate a network communication, pass through an internal queue. This includes READ and WRITE queries, close query requests, fetch requests, rollback/commit requests.\n\nThus, in order to put queries into a queue, all you need to do is call query/execute and their equivalent functions one after another. They will be added into the queue as they come in (FIFO).\n\nHere is an example.\n\n\tclient.execute('CREATE TABLE tbl_test(id INT)', callback);\n\tclient.execute('INSERT INTO tbl_test (id) VALUES (1), (2), (3)', callback);\n\tclient.query('SELECT * FROM tbl_test', callback);\n\tclient.execute('DROP TABLE tbl_test', callback);\n\nRemember that the `callback` is optional in which case you should listen for events.\n\nAlternatively, for backward compatibility we still support `addQeury()` and `addNonQuery()` functions which we introduced in version 2.0.0.\n\n    var SQL_1 = \"SELECT COUNT(*) FROM [code]\";\n    var SQL_2 = \"SELECT * FROM [code] WHERE s_name = 'X'\";\n    var SQL_3 = \"SELECT COUNT(*) FROM [code] WHERE f_name LIKE 'M%'\";\n    var SQL_4 = \"DELETE FROM code WHERE s_name = 'ZZZZ'\";\n\n    Helpers.logInfo('Executing [1]: ' + SQL_1);\n    client.addQuery(SQL_1, function (err, result) {\n      Helpers.logInfo('Result [1]: ' + Result2Array.RowsArray(result));\n    });\n\n    Helpers.logInfo('Executing [2]: ' + SQL_2);\n    client.addQuery(SQL_2, function (err, result) {\n      Helpers.logInfo('Result [2]: ' + Result2Array.RowsArray(result));\n    });\n\n    Helpers.logInfo('Executing [3]: ' + SQL_3);\n    client.addQuery(SQL_3, function (err, result) {\n      Helpers.logInfo('Result [3]: ' + Result2Array.RowsArray(result));\n    });\n\n    Helpers.logInfo('Executing [4]: ' + SQL_4);\n    client.addNonQuery(SQL_4, function (err) {\n      Helpers.logInfo('Result [4]: ' + err);\n      client.close();\n    });\n\n`addQuery()` will simply pass its arguments to the main `query()` function, while `addNonQuery()` will pass its arguments to `execute()` function. Thus, if you want to avoid one more function call, get used to directly calling the `query()` or `execute()` functions.\n\n##### Check if queue is empty\n\n\tclient.isQueueEmpty();\n\tclient.queriesQueueIsEmpty();\n\nIn case you are interested in checking if the queue is empty, call one of the above functions. Returns `true` or `false`.\n\n##### Get queue depth\n\n\tclient.getQueueDepth();\n\nThe above function will return the number of requests currently in the queue. Remember that this number represents all requests, including READ and WRITE, and fetch, and rollback/commit, etc. Briefly all requests which initiate a network communication.\n\n### Transactions\n\n\tclient.beginTransaction(callback);\n\tclient.commit(callback);\n\tclient.rollback(callback);\n\t\n\t// All `callback(err)` functions accept one argument: the error message if any.\n\n\tclient.setAutoCommitMode(boolean, callback);\n\t\n\t// `boolean` is a boolean value which represents the auto_commit\n\t//           mode you wish to set the current transaction to.\n\t\n\t// The `callback(err)` function accepts one argument: the error message if any.\n\t\n**node-cubrid** fully supports SQL transactions. By default `auto_commit` mode is set to `true` meaning after every WRITE query CUBRID Server will commit the changes to the disk.\n\nWhen you start a new transactaction by calling `beginTransaction()`, **node-cubrid** will first commit the previous active transaction if any. This is according to CUBRID spec. Then it will start a new transaction by setting the `auto_commit` mode to `false`.\n\n**Note:** Unlike in other DBMS vendor drivers, in **node-cubrid** when a transaction is rolled back or committed, the `auto_commit` mode remains unchanged, i.e. `false`. This is according to CUBRID spec. This means that after you commit/rollback the transaction and you no longer need to execute queries in `auto_commit = false` mode, explicitly turn the `auto_commit` mode to `true` by calling `setAutoCommitMode()` function.\n\n\tActionQueue.enqueue([\n\t\tfunction (cb) {\n\t\t\tclient.connect(cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tHelpers.logInfo('Connected...');\n\t\t\tclient.batchExecuteNoQuery('create table test_tran(id int)', cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tclient.beginTransaction(cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tclient.batchExecuteNoQuery('insert into test_tran values(1)', cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tclient.query('select * from test_tran', cb);\n\t\t},\n\t\tfunction (result, queryHandle, cb) {\n\t\t\tHelpers.logInfo('Should be true: ' + Result2Array.TotalRowsCount(result) === 1);\n\t\t\tclient.closeQuery(queryHandle, cb);\n\t\t},\n\t\tfunction (queryHandle, cb) {\n\t\t\tclient.rollback(cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tclient.query('select * from test_tran', cb);\n\t\t},\n\t\tfunction (result, queryHandle, cb) {\n\t\t\tHelpers.logInfo('Should be true: ' + Result2Array.TotalRowsCount(result) === 0);\n\t\t\tclient.closeQuery(queryHandle, cb);\n\t\t},\n\t\tfunction (queryHandle, cb) {\n\t\t\tclient.batchExecuteNoQuery('drop table test_tran', cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tclient.commit(cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\t// Explicitly set the auto commit mode to true, once done.\n\t\t\tclient.setAutoCommitMode(true, cb);\n\t\t},\n\t\tfunction (cb) {\n\t\t\tclient.query('select count(*) from db_class where class_name = \\'test_tran\\'', cb);\n\t\t},\n\t\tfunction (result, queryHandle, cb) {\n\t\t\tHelpers.logInfo('Should be true: ' + Result2Array.RowsArray(result)[0][0] === 0);\n\t\t\tclient.close(cb);\n\t\t}\n\t], function (err) {\n\t\tif (err) {\n\t\t\tthrow err;\n\t\t} else {\n\t\t\tHelpers.logInfo('Connection closed.');\n\t\t\tHelpers.logInfo('Test passed.');\n\t\t}\n\t});\n\n### Closing a connection\n\n\t// callback(err) function accepts one argument: the error message if any.\n\tclient.close(callback);\n\t// Alias function since version 2.1.0.\n\tclient.end(callback);\n\n#### Callback style\n\n\tclient.close(function (err) {\n\t\tif (err) {\n\t\t\tthrow err;\n\t\t} else {\t\t\t\n\t\t\tconsole.log('connection is closed');\n\t\t}\n\t});\n\n#### Event style\n\n\tclient.connect();\n\t\n\tclient.on(client.EVENT_CONNECTED, function () {\n\t\t\tconsole.log('connection is established');\n\t\t\t\n\t\t\tclient.close();\n\t});\n\n\tclient.on(client.EVENT_CONNECTION_CLOSED, function () {\n\t\t\tconsole.log('connection is closed');\n\t});\n\nWhen a connection is closed by calling `close()` or `end()`, all pending/queued requests will be removed from the internal queue.\n\n#### Errors on closing the connection\n\nThe following errors may be emitted when the application tries to close the connection:\n\n1. If a connection is already closed, the following error is emitted by **node-cubrid**.\n\t\n\t\t{ [Error: The connection is already closed!] }\n\n2. If closing a connection was unsuccessful, an error message returned by a database is emitted.\n\n### Events by EventEmitter\n\n**node-cubrid** implements, in addition to the standard callbacks model functionality, a rich event model:\n\n| Event name | Notes |\n| ---------------- | --------|\n| `EVENT_ERROR` | Emitted when an error is occurs. |\n| `EVENT_CONNECTED` | Emitted when a connection is established. |\n| `EVENT_ENGINE_VERSION_AVAILABLE` | Emitted when the database version information is returned from the server to a client. |\n| `EVENT_BATCH_COMMANDS_COMPLETED` | Emitted when the batch commands execution is completed. |\n| `EVENT_QUERY_DATA_AVAILABLE` | Emitted when the data from the query is available to a client. |\n| `EVENT_SCHEMA_DATA_AVAILABLE` | Emitted when the database schema information is available to a client. |\n| `EVENT_FETCH_DATA_AVAILABLE` | Emitted when more query data is available to a client through successive `fetch()` command(s). |\n| `EVENT_FETCH_NO_MORE_DATA_AVAILABLE` | Emitted when no more data is available from the query. |\n| `EVENT_BEGIN_TRANSACTION` | Emitted when a transaction is started in `auto_commit = OFF` mode. |\n| `EVENT_SET_AUTOCOMMIT_MODE_COMPLETED` | Emitted when the auto-commit mode is changed. |\n| `EVENT_COMMIT_COMPLETED` | Emitted when a commit request is completed. |\n| `EVENT_ROLLBACK_COMPLETED` | Emitted when a rollback request is completed. |\n| `EVENT_QUERY_CLOSED` | Emitted when a query is closed. |\n| `EVENT_CONNECTION_CLOSED` | Emitted when a connection is closed. |\n[**Table 1: Events emitted by node-cubrid**]\n\n## More examples\n\nThe driver code release contains many demo examples and test cases which you can find in the following directories:\n\n- [/demo](https://github.com/CUBRID/node-cubrid/tree/master/demo)\n- [/test](https://github.com/CUBRID/node-cubrid/tree/master/test)\n\nHere is another **node-cubrid** usage example which uses the `ActionQueue` helper. The `ActionQueue.enqueue` function is the same as the [async.waterfall()](https://github.com/caolan/async#waterfall) from the well-known **async** library:\n\n\tvar CUBRID = require('node-cubrid'),\n\t\tActionQueue = CUBRID.ActionQueue,\n\t\tHelpers = CUBRID.Helpers,\n\t\tclient = CUBRID.createDefaultCUBRIDDemodbConnection();\n\n    ActionQueue.enqueue([\n        function (cb) {\n           client.connect(cb);\n        },\n        function (cb) {\n          client.getEngineVersion(cb);\n        },\n        function (engineVersion, cb) {\n          Helpers.logInfo('Engine version is: ' + engineVersion);\n          client.query('select * from code', cb);\n        },\n        function (result, queryHandle, cb) {\n          Helpers.logInfo('Query result rows count: ' + Result2Array.TotalRowsCount(result));\n          Helpers.logInfo('Query results:');\n          var arr = Result2Array.RowsArray(result);\n\n          for (var k = 0; k < arr.length; k++) {\n            Helpers.logInfo(arr[k].toString());\n          }\n          \n          client.closeQuery(queryHandle, cb);\n        },\n        function (cb) {\n          Helpers.logInfo('Query closed.');\n          client.close(cb);\n        }\n      ], function (err) {\n        if (err) {\n          throw err;\n        } else {\n          Helpers.logInfo('Connection closed.');\n        }\n      }\n    );\n\t\nYou can also find more tutorials at [http://www.cubrid.org/wiki_apis/entry/cubrid-node-js-tutorials](http://www.cubrid.org/wiki_apis/entry/cubrid-node-js-tutorials).\n\n## Running tests\n\nTo run tests on **node-cubrid** module:\n\n1. `npm install` all testing framework development dependencies.\n2. Make sure:\n\t1. CUBRID Server 8.4.1+ is installed on `localhost`.\n\t2. CUBRID Broker is listening on port `33000`.\n\t3. `demodb` database is running.\n3. Alternatively, edit test suite connection configurations at `test/testSetup/test_Setup.js` and change the connection information.\n4. `npm test` to start testing.\n\nThere are over 268K assertion tests which should all pass on CUBRID 8.4.1+.\n\n## What's next\n\nWe intend to continuosly improve this driver, by adding more features and improving the existing code base.\n\nAnd you are more than welcomed to suggest what we should improve or add - please let us know! :)\n\n\n## Authors and Contributors\n\nThe authors of this driver are the members of the CUBRID API team - [http://www.cubrid.org/wiki_apis](http://www.cubrid.org/wiki_apis).\n\nWe welcome any new contributors and we hope you will enjoy using and coding with CUBRID! :)\n\n### Special thanks\n\nWe would like to say thanks to the following people & projects for inspiration,\nfor the code we have (re)used and for doing such a great job for the open-source community!\n\n-\t[https://github.com/caolan/async](https://github.com/caolan/async)\n-\t[https://github.com/felixge/node-mysql](https://github.com/felixge/node-mysql)\n-\t[https://github.com/jeromeetienne/microcache.js](https://github.com/jeromeetienne/microcache.js)\n\n...Stay tuned for the next great driver releases! :)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cubrid/node-cubrid/issues"
  },
  "_id": "node-cubrid@2.2.0",
  "dist": {
    "shasum": "6b29916c9cb091a7be50d90856037145daa44b12"
  },
  "_from": "node-cubrid@",
  "_resolved": "https://registry.npmjs.org/node-cubrid/-/node-cubrid-2.2.0.tgz"
}
